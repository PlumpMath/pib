\section{Crowd plug-in}

The goal of this work package was to implement the movement of the crowd. At first we wanted to implement a general movement algorithm and an other algorithm that would control the animation of the crowd. The second part was quite difficult to implement and thus we decided to concentrate ourselves on the first part.\\
Our algorithm is split into two parts one that is independant from Blender and one that depends on it. \\
The first part create a set of key points that will represent the movement of one person and the second interpolate a trajectory from those points.

% Il faudra changer les titres je pense 
\subsection{Algorithm description}

The first algorithm is inspired by those two papers: \cite{PLE} and \cite{vandenBerg2011}. We choosed them because the notions involved in the describtion of the algorithm were more familiar to us.
% TODO : combler avec du bla bla
The idea is the following: a graph (grid) algorithm will generate a general path that for each individual and another algorithm will prevent collisions between individuals. We descretize the time in order to compute a next point for each individual easily. This is how we get the final set of points for each individuals.

\subsection{Algorithm implementation}

\subsubsection{The guide graph}

The first part that we tried to implement was the graph. We created a data structure reprensenting the nodes of the graph and the edges. This was quite easy to do since the graph is suposed to be a grid, it is regular.
Then we needed a minimum distance (1 to 1) algorithm on the graph. For that we choosed the $A^*$ algorithm. Unfortunaly, our implementation of the $A^*$ was realy costly in time and even more in memory. This fact forced us to abandon the graph in the rest of the devellopement. We could test it for small values, and for a small number of calls, but the $A^*$ would have to be called thousands of times which makes this impractical. 
To replace the graph we used the euclidian distance, this involved removing statics obstacles. Also the points were no more able to avoid packed places and just went strait to there goal.

\subsubsection{Allowed velocity field}

This part deals with collision avoidance. This part is the part that took us the more time to implement. The problem is the following, you have a set of individual (i.e. points) with current velocities. You want for each individuals a set of velocities that will ensure that  if we peek one in it then we will not colide with another individual on the way. To do that the algorithm makes a lot of geometrical computation as you can see in \cite{vandenBerg2011}. We used the python library Shalely to reprensent geometrical structures. This library has some very usefull tools but some functionalities do not work very well with the flotants and the small errors that they provied. The errors linked to the flotant are one of the main reason it took us time. The other was that some geometrical forms were hard to reprensent and to compute both theoriticaly and computationaly.
Also due to the absence of the guide graph, the individuals were not able to go around obstables so it induced bugs, the points tends to get closer and closer to the limits of the obstacle until they cross it through errors and thus go through obstacles.
In the end, this part does return collisions free velocities in 95\% of cases. There are still some bugs that we were not able to find.

\subsubsection{Computation of the allowed movement}

This part involves minimizing a function on the velocity field of each individuals. For that we had two options. The first one was to implement a simplex but the graph was not a linear constraint so we though that this was not a valid way to minimize. The second method was to choose an angle and incrementing it according to a $d\theta$ and minimizing the function on those angles.
This part is fully functionnal but relied on flotants again involving computional errors.